1、基本类型：
    布尔值:boolean

    数字:number(支持十进制、十六进制、二进制和八进制字面量)。

    字符串:string(使用双引号（ "）或单引号（'）表示字符串,还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围 ` ，并且以${ expr }这种形式嵌入表达式)。

    数组:有两种方式可以定义数组。 第一种，可以在元素类型后面接上 []，表示由此类型元素组成的一个数组;第二种方式是使用数组泛型，Array<元素类型>。

    元组 Tuple:元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。当访问一个已知索引的元素，会得到正确的类型，当访问一个越界的元素，会使用联合类型替代。

    枚举:enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值从1开始，或全部
        手动赋值。枚举类型提供的一个便利是你可以由枚举的值得到它的名字。

    Any：有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让
        它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量。在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为 Object有相似的作
        用，就像它在其它语言中那样。 但是 Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法。

    Void:某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void。声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null。

    Null 和 Undefined:TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似，它们的本身的类型用处不是很大。默认情况下null和undefined是所有类型的子类型。 就是
                     说你可以把 null和undefined赋值给number类型的变量。然而，当你指定了--strictNullChecks标记，null和undefined只能赋值给void和它们各自。
                    
    Never:never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类
         型保护所约束时。never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。

    Null、Undefined和Never可以赋给任意类型，可以赋给Null和Undefined的类型有：Null、Undefined和any，不能赋给Never任何类型的值，除了never。

2、类型断言：有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。通过类型断言这种方式可以告诉编译器，“相信我，我知道自
己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。
类型断言有两种形式：使用尖括号和使用as。

3、接口：接口的作用就是为类型命名和为你的代码或第三方代码定义契约。接口里面不能进行初始化。
    将某个类型赋值给某一接口类型时，只需要其值满足接口所要求的即可。

    类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。

    可选属性：接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。带有可选属性的接口与普通
            的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。

    只读属性：一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性。TypeScript具有ReadonlyArray<T>类型，它与Array<T>相似，只是把所有可变方法去掉了，因此可以
            确保数组创建后再也不能被修改。           
    readonly vs const：最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用const，若做为属性则使用readonly。

    额外的属性检查：对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。
    解决额外属性检查的方法：
        1、添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。这样可以让该类型带有任意数量的其他属性。
        2、使用类型断言来绕开这些检查。
        3、将对象字面量赋值给另一个变量，这样可以避免额外的属性检查。
    简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的bug。 就是说你遇到了额外类型检查出的错误，比如“option bags”，
    你应该去审查一下你的类型声明。

    函数类型：接口能够描述JavaScript中对象拥有的各种各样的外形。除了描述带有属性的普通对象外，接口也可以描述函数类型。为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数
            列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。函数的参数会逐个进行检查，要求对应位置上的参数类
            型是兼容的。 如果你不想指定类型，TypeScript的类型系统会推断出参数类型，函数的返回值类型也是通过其返回值推断出来的，如果返回的类型不匹配，类型检查器会警告我们函数的返回值类型与接口中的定
            义不匹配。

    可索引的类型：与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap["daniel"]。 可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 
               共有支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string
               然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用"100"（一个string）去索引，因此两者需要保持一致。字符串索引签名能够很好的描述dictionary模式，并且它们也会确保所有属性
               与其返回值类型相匹配。 因为字符串索引声明了 obj.property和obj["property"]两种形式都可以。可以将索引签名设置为只读，这样就防止了给索引赋值。

    类类型：
        1、实现接口：与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约。接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。
        2、类静态部分与实例部分的区别：当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时
          会得到一个错误。这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。

    继承接口：和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。一个接口可以继承多个接口，创建出多个接口的合成接口。

    混合接口：一个对象可以同时做为函数和对象使用，并带有额外的属性。在使用JavaScript第三方库的时候，你可能需要像上面那样去完整地定义类型。

    接口继承类：当接口继承了一个类类型时，它会继承类的成员但不包括其实现。就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了
             一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。
             这个子类除了继承至基类外与基类没有任何关系。

4、类：
    TypeScript使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。然而，当我们比较带有 private或 protected成员的类
    型的时候，情况就不同了。 如果其中一个类型里包含一个 private成员，那么只有当另外一个类型中也存在这样一个 private成员， 并且它们都是来自同一处声明时(例如，一个子类继承一个父类的private成员)，我们才
    认为这两个类型是兼容的。 对于 protected成员也使用这个规则。

    继承：在TypeScript里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。类从基类中继承了属性和方法。通过extends关键字。 派生类通常被称作 子类，基类
         通常被称作超类。派生类如果包含了构造函数，它必须调用super()，他会执行基类的构造函数。而且，在构造函数里访问this的属性之前，我们 一定要调用 super()。 这个是TypeScript强制执行的一条重要规则。

    公共、私有与受保护的修饰符：默认为public。
        public：成员可以在声明它的类的外部访问。
        private：当成员被标记成 private时，它就不能在声明它的类的外部访问。
        protected：成员不能在外部使用，可以在派生类中使用。构造函数也可以被标记成 protected。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。

    readonly修饰符：你可以使用readonly关键字将属性设置为只读的。只读属性必须在声明时或构造函数里被初始化。

    参数属性：可以方便地让我们在一个地方定义并初始化一个成员。参数属性通过给构造函数参数添加一个访问限定符来声明。

    存取器：TypeScript支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。存取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。 其次，只带有
    get不带有 set的存取器自动被推断为 readonly。 这在从代码生成 .d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许改变它的值。

    
    
