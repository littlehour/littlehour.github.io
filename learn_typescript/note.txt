1、基本类型：
    布尔值:boolean

    数字:number(支持十进制、十六进制、二进制和八进制字面量)。

    字符串:string(使用双引号（ "）或单引号（'）表示字符串,还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围 ` ，并且以${ expr }这种形式嵌入表达式)。

    数组:有两种方式可以定义数组。 第一种，可以在元素类型后面接上 []，表示由此类型元素组成的一个数组;第二种方式是使用数组泛型，Array<元素类型>。

    元组 Tuple:元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。当访问一个已知索引的元素，会得到正确的类型，当访问一个越界的元素，会使用联合类型替代。

    枚举:enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值从1开始，或全部
        手动赋值。枚举类型提供的一个便利是你可以由枚举的值得到它的名字。

    Any：有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让
        它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量。在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为 Object有相似的作
        用，就像它在其它语言中那样。 但是 Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法。

    Void:某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void。声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null。

    Null 和 Undefined:TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似，它们的本身的类型用处不是很大。默认情况下null和undefined是所有类型的子类型。 就是
                     说你可以把 null和undefined赋值给number类型的变量。然而，当你指定了--strictNullChecks标记，null和undefined只能赋值给void和它们各自。
                    
    Never:never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类
         型保护所约束时。never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。

    Null、Undefined和Never可以赋给任意类型，可以赋给Null和Undefined的类型有：Null、Undefined和any，不能赋给Never任何类型的值，除了never。

2、类型断言：有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。通过类型断言这种方式可以告诉编译器，“相信我，我知道自
己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。
类型断言有两种形式：使用尖括号和使用as。

3、接口：接口的作用就是为类型命名和为你的代码或第三方代码定义契约。接口里面不能进行初始化。
    将某个类型赋值给某一接口类型时，只需要其值满足接口所要求的即可。

    类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。

    可选属性：接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。带有可选属性的接口与普通
            的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。

    只读属性：一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性。TypeScript具有ReadonlyArray<T>类型，它与Array<T>相似，只是把所有可变方法去掉了，因此可以
            确保数组创建后再也不能被修改。           
    readonly vs const：最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用const，若做为属性则使用readonly。

    额外的属性检查：对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。
    解决额外属性检查的方法：
        1、添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。这样可以让该类型带有任意数量的其他属性。
        2、使用类型断言来绕开这些检查。
        3、将对象字面量赋值给另一个变量，这样可以避免额外的属性检查。
    简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的bug。 就是说你遇到了额外类型检查出的错误，比如“option bags”，
    你应该去审查一下你的类型声明。

    函数类型：接口能够描述JavaScript中对象拥有的各种各样的外形。除了描述带有属性的普通对象外，接口也可以描述函数类型。为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数
            列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。函数的参数会逐个进行检查，要求对应位置上的参数类
            型是兼容的。 如果你不想指定类型，TypeScript的类型系统会推断出参数类型，函数的返回值类型也是通过其返回值推断出来的，如果返回的类型不匹配，类型检查器会警告我们函数的返回值类型与接口中的定
            义不匹配。

    可索引的类型：与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap["daniel"]。 可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 
               共有支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string
               然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用"100"（一个string）去索引，因此两者需要保持一致。字符串索引签名能够很好的描述dictionary模式，并且它们也会确保所有属性
               与其返回值类型相匹配。 因为字符串索引声明了 obj.property和obj["property"]两种形式都可以。可以将索引签名设置为只读，这样就防止了给索引赋值。

    类类型：
        1、实现接口：与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约。接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。
        2、类静态部分与实例部分的区别：当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时
          会得到一个错误。这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。

    继承接口：和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。一个接口可以继承多个接口，创建出多个接口的合成接口。

    混合接口：一个对象可以同时做为函数和对象使用，并带有额外的属性。在使用JavaScript第三方库的时候，你可能需要像上面那样去完整地定义类型。

    接口继承类：当接口继承了一个类类型时，它会继承类的成员但不包括其实现。就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了
             一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。
             这个子类除了继承至基类外与基类没有任何关系。

4、类：
    TypeScript使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。然而，当我们比较带有 private或 protected成员的类
    型的时候，情况就不同了。 如果其中一个类型里包含一个 private成员，那么只有当另外一个类型中也存在这样一个 private成员， 并且它们都是来自同一处声明时(例如，一个子类继承一个父类的private成员)，我们才
    认为这两个类型是兼容的。 对于 protected成员也使用这个规则。

    继承：在TypeScript里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。类从基类中继承了属性和方法。通过extends关键字。 派生类通常被称作 子类，基类
         通常被称作超类。派生类如果包含了构造函数，它必须调用super()，他会执行基类的构造函数。而且，在构造函数里访问this的属性之前，我们 一定要调用 super()。 这个是TypeScript强制执行的一条重要规则。

    公共、私有与受保护的修饰符：默认为public。
        public：成员可以在声明它的类的外部访问。
        private：当成员被标记成 private时，它就不能在声明它的类的外部访问。
        protected：成员不能在外部使用，可以在派生类中使用。构造函数也可以被标记成 protected。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。

    readonly修饰符：你可以使用readonly关键字将属性设置为只读的。只读属性必须在声明时或构造函数里被初始化。

    参数属性：可以方便地让我们在一个地方定义并初始化一个成员。参数属性通过给构造函数参数添加一个访问限定符来声明。

    存取器：TypeScript支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。存取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。 其次，只带有
    get不带有 set的存取器自动被推断为 readonly。 这在从代码生成 .d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许改变它的值。

    静态属性：我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。每个实例想要访问这个属性的时候，都要在前面加上类名。

    抽象类：抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化(也不可直接被实例化)。 不同于接口，抽象类可以包含成员的实现细节。 abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法。抽象类中
    的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 abstract关键字并且可以包含访问修饰符。
    
类定义会创建两个东西：类的实例类型和一个构造函数。其中，构造函数类型包含了类的所有静态成员(static)和构造函数。 

5、函数：
    和JavaScript一样，TypeScript函数可以创建有名字的函数和匿名函数。 你可以随意选择适合应用程序的方式，不论是定义一系列API函数还是只使用一次的函数。

    我们可以给每个参数添加类型之后再为函数本身添加返回值类型。 TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它。

    函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。 这个名字只是为了增加可读性。只要参数类型是匹
    配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。第二部分是返回值类型。 对于返回值，我们在函数和返回值类型之前使用( =>)符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如
    果函数没有返回任何值，你也必须指定返回值类型为 void而不能留空。

    函数的类型只是由参数类型和返回值组成的。 函数中使用的捕获变量不会体现在类型里。 实际上，这些变量是函数的隐藏状态并不是组成API的一部分。

    推断类型：在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript编译器会自动识别出类型，这叫做“按上下文归类”，是类型推论的一种。 它帮助我们更好地为程序指定类型。

    可选参数和默认参数：TypeScript里的每个函数参数都是必须的。 这不是指不能传递 null或undefined作为参数，而是说编译器检查用户是否为每个参数都传入了值。 编译器还会假设只有这些参数会被传递进函数。 简短地
    说，传递给一个函数的参数个数必须与函数期望的参数个数一致。JavaScript里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是undefined。 在TypeScript里我们可以在参数名旁使用 ?实现可选参数的功能。
    可选参数必须跟在必须参数后面。在TypeScript里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是undefined时。 它们叫做有默认初始化值的参数。在所有必须参数后面的带默认初始化的参数都是可
    选的，与可选参数一样，在调用函数的时候可以省略。 也就是说可选参数与末尾的默认参数共享参数类型。(当默认参数位于必须参数后面时，与可选参数同参数类型)。与普通可选参数不同的是，带默认值的参数不需要放在必
    须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入 undefined值来获得默认值。

    剩余参数：必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在JavaScript里，你可以使用 arguments来访问所有传入的参数。
    在TypeScript里，你可以把所有参数收集到一个变量里。剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（ ...）后面给定的名字，你可以在函数体
    内使用这个数组。这个省略号也会在带有剩余参数的函数类型定义上使用到。

    this：TypeScript能通知你错误地使用了 this的地方。
        this和箭头函数：JavaScript里，this的值在函数被调用的时候才会指定。在返回一个函数或将函数当做参数传递(例如：回调)的时候，常常会遇到this指向的并非我所希望的对象，而是之后在全局上下文调用的window(
        严格模式下是undefined)。为了解决这个问题，我们可以在函数被返回时就绑好正确的this。 这样的话，无论之后怎么使用它，都会引用绑定的对象。 我们需要改变函数表达式来使用ECMAScript 6箭头语法。箭头函数能
        保存函数创建时的 this值，而不是调用时的值。

        this参数在回调函数里：你也可以看到过在回调函数里的this报错，当你将一个函数传递到某个库函数里稍后会被调用时。 因为当回调被调用的时候，它们会被当成一个普通函数调用， this将为undefined。

    重载：为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用。为了让编译器能够选择正确的检查类型，它与JavaScript里的处理流程相似。 它查找重载列表，尝试使用第一个重载定义。
    如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面。

6、泛型：
    类型变量T可以帮助我们捕获用户传入的类型（比如：number），之后我们就可以使用这个类型，以及将其当做返回值类型。 不同于使用 any，它不会丢失信息。定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的
    参数，包含类型参数。第二种方法利用了类型推论 -- 即编译器会根据传入的参数自动地帮助我们确定T的类型。

    使用泛型变量：使用泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。

    泛型类型：泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面。我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。我们还可以使用带有调用签名的对象字面量来定义泛型
    函数，也可以将这个对象字面量写成一个接口，还可以将泛型参数当做整个接口的一个参数，这样我们就能清楚的知道使用的具体是哪个泛型类型（比如： Dictionary<string>而不只是Dictionary），这样接口里的其它成员也
    能知道这个参数的类型了。