一、指令：
    指令可以是DOM元素里面的一个属性(attribute)、元素(element)、注释(comment)、CSS类(CSS class)。一个指令会告知Angularjs的HTML编译器($compile)，给使用指令的DOM元素附加一个具体的行为(例如通过事件监听)，
或者转换DOM元素和他的子元素。Angularjs有一些内置的指令，像：ngBind、ngModel和ngClass。像创建控制器和服务一样，你可以创建自定义的angularjs指令来供使用。当angularjs初始化你的应用时，HTML compile会遍历DOM
树，匹配指令到相应的DOM元素。对于angularjs来说，"compilation"意味着给html附加指令，让他可以交互。
    匹配指令：和元素匹配选择器一样，当指令是元素的部分声明时，则可以说元素匹配这个指令。

    指令正规化：angularjs规范一个元素标签和属性名来决定那个元素匹配那个指令。指令的正规化过程：
    1、忽略元素和属性名的x-和data-前缀。
    2、转换：，-，_这些分隔符为驼峰形式。
    最好使用-分割形式，如果你想使用HTML验证工具，你可以使用data-前缀。另外的格式是合法的，但不建议使用。

    指令类型：$compile可以以元素名(E)，属性(A)，类名(C)和注释(M)为基础来匹配指令。在指令定义对象中，可以使用restrict来声明指令的类型，默认是EA。最好使用标签类和属性类指令，这样更容易决定某个元素匹配什么指令。
    注释指令普遍使用在DOM API限制创建指令的地方。

    创建指令：像注册控制器一样，指令注册在module上，module.directive接收一个规范的指令名（驼峰式）和一个factory函数最为参数。factory函数应该返回一个有各种选项的对象来告诉$compile，当指令匹配时，应该有什么行为。
    factory函数只会在compile匹配指令时调用一次，因此你可以在哪里面进行一些初始化工作，这个函数使用$injector.invoke调用，因此他像控制器一样是可以注入的。自定义的指令最好加上一个不会与将来的html产生冲突的前缀。

    指令选项：
    1、template：当一个模板在很多地方被使用时，可以为其创建一个指令。在这个选项里，你可以组合一些另外的指令像绑定{{expression}}。这个选项适用模板比较小的时候，值为一个模板字符串。
    2、templateUrl：引用一个html文件作为模板。他的值可以是一个返回HTML模板文件URL的函数，这个函数接收两个参数，与指令相关的元素和元素的属性对象，你无法在该函数中访问作用域变量，因为模板的请求先于作用域的初始化。
    3、restrict：指令类型，有四个值，A、E、C、M，默认为AE。当创建组件的时候一般会使用E，当想要给已经存在的元素提供新功能时一般会使用A。
    4、scope：用来将指令内部的作用域与外部隔离，然后将外部的作用域映射到指令内部。有三个值：
        false：默认值，不会为这个指令创建单独的作用域，而是使用父作用域。
        true：会为这个指令创建一个继承父作用域的子作用域，如果某个元素上有多个指令要求创建一个新的作用域，只会有一个指令被创建。
        {}：一个hash对象，会为指令的模板创建一个隔离的作用域。隔离作用域和正常的作用域不同，隔离作用域不会继承他的父作用域。这对于创建可重用的组件很有用，这样会避免无意的修改或读取父作用域的数据。如果一个隔离作用域
        指令没有使用template或templateUrl选项，那么这个隔离作用域不会应用于他的子元素。这个hash对象的key映射到隔离作用域属性的名字，value定义了这个属性如何绑定到父作用域，通过匹配指令元素的属性。有四种绑定方式：
            @或@attr：绑定指令作用域的属性到DOM属性的值，这个属性的值为字符串，因为DOM的属性值为字符串，如果attr未指定，则会认为是匹配和指令作用域相同属性名的DOM属性。指令作用域属性的值会随绑定的父作用域的属性值的
            改变而改变，但指令作用域属性值的改变不会影响父作用域。

            =或=attr：在指令作用域的属性和传递给DOM属性attr的表达式之间建立一个双向绑定。表达式在父作用域下执行。如果attr未指定，则会认为是匹配和指令作用域相同属性名的DOM属性。指令作用域属性的值会随绑定的父作用域
            的属性值的改变而改变，反之亦然。可选属性使用=?或=?attr来表示。如果绑定的表达式是不可赋值的，或者未使用可选属性=?或=?attr，而这个属性在DOM属性中不存在，那么当修改指令作用域属性的值时，会抛出一个
            $compile:nonassign的异常，因为这个修改无法同步到父作用域。默认，使用$watch方法来跟踪改变，相等检查是以对象标识符为基础的，然而，如果传递一个对象字面量或数组字面量作为绑定的表达式，相等检查会以值的方式
            进行深度检查(使用angular.equals函数)，当然也可以使用$watchCollection(使用=*或=*attr，可选属性使用=*?或=*?attr)来进行浅显的检查。

            <或<attr：在指令作用域的属性和传递给DOM属性attr的表达式之间建立一个单向绑定。表达式在父作用域下执行。如果attr未指定，则会认为是匹配和指令作用域相同属性名的DOM属性。可选属性使用<?或<?attr来表示。指令作
            用域属性的值会随绑定的父作用域的属性值的改变而改变，但指令作用域属性值的改变不会影响父作用域。有以下两个注意事项：
                1、单向绑定并不是复制父作用域的值到指令作用域，而是简单的设置为相同的值。这意味着如果你绑定的值为一个对象，在指令作用域修改这个对象的属性将会影响父作用域，因为引用的是同一个对象。
                2、单向绑定会监视父作用域属性值标识符的改变。这意味着在父作用域属性值上的监视仅仅会触发当值的引用发生改变时。在大多数情况下，这并不值得关注，但是是重要的来了解当单向绑定绑定到一个对象，然后，在指令作
                用域修改了对象的引用，如果你现在在父作用域修改对象的属性，这个修改就不会影响到指令作用域，因为父作用域的对象标识符并没有改变。
            如果你不想在指令作用域的修改影响父作用域，那么单向绑定是有用的，但如果绑定的是对象，还是有可能会影响到父作用域。

            &或&attr：提供一个在父作用域的上下文执行表达式的方法。如果attr未指定，则会认为是匹配和指令作用域相同属性名的DOM属性。指令作用域的属性会指向一个函数，这个函数包含了传递给DOM属性attr的表达式。这个常常用来
            在指令作用域传递数据给父作用域，例如可以传递一个指令作用域属性和值的hash对象给父作用域。如果传递给DOM属性attr的表达式是调用一个函数，这样也可以起到一个对指令行为绑定回调函数的效果。

            当在一个元素上使用多个指令时，会有一些限制，取决于scope的类型，以一个元素上使用两个指令为例：
                false+false：使用父作用域
                true+false：分享一个子作用域
                true+true：分享一个子作用域
                {}+false：隔离作用域使用自己创建的隔离作用域，false的使用父作用域。
                {}+true：无法运行，一个元素只能关联一个作用域，因此这些指令不能被应用到一个元素。
                {}+{}：无法运行，一个元素只能关联一个作用域，因此这些指令不能被应用到一个元素。
    5、link：用来修改DOM或为DOM元素添加事件监听器，在模板克隆后执行，指令逻辑会放在这里。link接收的函数签名为，function link(scope, element, attrs, controller, transcludeFn) { ... }：
        scope:一个angularjs的scope对象。如果指令有创建作用域，则scope为指令的作用域，否则为父作用域。
        element：该指令匹配的jqLite包装的元素。
        attrs：一个hash键值对对象，key为指令匹配元素的属性名，value为相应属性的值。
        controller：指令选项中通过require指定的控制器实例，或者该指令自己拥有的控制器实例，到底是哪个取决于指令选项require属性的值。
        transcludeFn：一个嵌入的预绑定到正确嵌入作用域的链接函数。
    当一个DOM Node已经被$compile编译，然后被删除，会触发一个$destroy事件。在这个事件的处理器里，可以做一些清理工作以免发生内存泄漏。
    6、tansclude：允许指令嵌入任何内容，且使内容使用的作用域为指令外部的作用域。
    7、require：如果该属性指定的控制器没有被找到，$compile会抛一个错误。^^前缀会在父辈和祖辈元素搜索相关控制器，^前缀会在该元素或父辈和祖辈元素搜索相关控制器，没有任何前缀时，就只会在该元素搜索相关控制器。
    8、controller：附加一个控制器到指令模板。
    9、controllerAs：为控制器定义一个别名。


    

